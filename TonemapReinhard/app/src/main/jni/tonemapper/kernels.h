#ifndef KERNELS_H
#define KERNELS_H

/// OpenCL kernels are defined in this file.

const char tonemapSource[] =
    "__kernel void to_float(__global uchar4 *gIn,           \n"
    "        __global float4 *gOut) {                       \n"
    "    int gid = get_global_id(1) * get_global_size(0)    \n"
    "               + get_global_id(0);                     \n"
    "    uchar4 in = gIn[gid];                              \n"
    "    float4 out;                                        \n"
    "    float f;                                           \n"
    "    if(in.s3 != 0) {                                   \n"
    "        f = ldexp(1.0f, (in.s3 & 0xFF) - (128 + 8));   \n"
    "        out.s0 = (in.s0 & 0xFF) * f;                   \n"
    "        out.s1 = (in.s1 & 0xFF) * f;                   \n"
    "        out.s2 = (in.s2 & 0xFF) * f;                   \n"
    "    }                                                  \n"
    "    else {                                             \n"
    "        out.s0 = 0.0f;                                 \n"
    "        out.s1 = 0.0f;                                 \n"
    "        out.s2 = 0.0f;                                 \n"
    "    }                                                  \n"
    "    gOut[gid] = out;                                   \n"
    "}                                                      \n"
    "                                                       \n"
    "__kernel void to_yxy(__global float4 *gData,           \n"
    "        __global float4 *unun) {                       \n"
    "    int gid = get_global_id(1) * get_global_size(0)    \n"
    "               + get_global_id(0);                     \n"
    "    float4 result = (float4)(0.0f);                    \n"
    "    float4 pixel = gData[gid];                         \n"
    "                                                       \n"
    "    // These constants are the conversion coefs.       \n"
    "    result.s0 += 0.5141364f * pixel.s0;                \n"
    "    result.s0 += 0.3238786f * pixel.s1;                \n"
    "    result.s0 += 0.16036376f * pixel.s2;               \n"
    "    result.s1 += 0.265068f * pixel.s0;                 \n"
    "    result.s1 += 0.67023428f * pixel.s1;               \n"
    "    result.s1 += 0.06409157f * pixel.s2;               \n"
    "    result.s2 += 0.0241188f * pixel.s0;                \n"
    "    result.s2 += 0.1228178f * pixel.s1;                \n"
    "    result.s2 += 0.84442666f * pixel.s2;               \n"
    "    float w = result.s0 + result.s1 + result.s2;       \n"
    "                                                       \n"
    "    if(w > 0.0f) {                                     \n"
    "        pixel.s0 = result.s1;     // Y                 \n"
    "        pixel.s1 = result.s0 / w; // x                 \n"
    "        pixel.s2 = result.s1 / w; // y                 \n"
    "    }                                                  \n"
    "    else {                                             \n"
    "        pixel = (float4) (0.0f);                       \n"
    "    }                                                  \n"
    "                                                       \n"
    "    gData[gid] = pixel;                                \n"
    "}                                                      \n"
    "                                                       \n"
    "__kernel void line_log_average(__global float4 *gData, \n"
    "        __global float4 *unun,                         \n"
    "        __global float4 *lineLogAverageData,           \n"
    "        int lineLogAverageWidth) {                     \n"
    "    int base = get_global_id(1) * lineLogAverageWidth; \n"
    "    float sum = 0.0f;                                  \n"
    "    float max = 0.0f;                                  \n"
    "                                                       \n"
    "    for(int i = 0; i < lineLogAverageWidth; ++i) {     \n"
    "        float val = gData[base + i].s0;                \n"
    "        sum += log(0.00001f + val);                    \n"
    "        if(val > max)                                  \n"
    "            max = val;                                 \n"
    "    }                                                  \n"
    "                                                       \n"
    "    gData[base].s3 = sum;                              \n"
    "    gData[base + 1].s3 = max;                          \n"
    "}                                                      \n"
    "                                                       \n"
    "__kernel void log_average(__global float4 *gData,      \n"
    "        __global float4 *unun,                         \n"
    "        __global float4 *logAverageData,               \n"
    "        int logAverageWidth,                           \n"
    "        int logAverageHeight, float logAverageKey) {   \n"
    "    float sum = 0.0f;                                  \n"
    "    float max = 0.0f;                                  \n"
    "                                                       \n"
    "    for(int i = 0; i < logAverageHeight; ++i) {        \n"
    "        sum += gData[logAverageWidth * i].s3;          \n"
    "                                                       \n"
    "        float val = gData[logAverageWidth * i + 1].s3; \n"
    "        if(val > max)                                  \n"
    "            max = val;                                 \n"
    "    }                                                  \n"
    "                                                       \n"
    "    // Save the scale factor on gData[0].s3.           \n"
    "    float average = exp(sum / (float)(logAverageWidth  \n"
    "        * logAverageHeight));                          \n"
    "    float scaleFactor = logAverageKey                  \n"
    "        * (1.0f / average);                            \n"
    "    gData[0].s3 = scaleFactor;                         \n"
    "                                                       \n"
    "    // Save lmax2 on gData[1].s3.                      \n"
    "    gData[1].s3 = pow(max * scaleFactor, 2);           \n"
    "}                                                      \n"
    "                                                       \n"
    "__kernel void tonemap(__global float4 *gData,          \n"
    "        __global float4 *unun,                         \n"
    "        __global float4 *tonemapData) {                \n"
    "    int gid = get_global_id(1) * get_global_size(0)    \n"
    "               + get_global_id(0);                     \n"
    "    float s0 = gData[gid].s0;                          \n"
    "                                                       \n"
    "    // Scale to midtones.                              \n"
    "    // gData[0].s3 contains the scale factor.          \n"
    "    s0 *= gData[0].s3;                                 \n"
    "                                                       \n"
    "    // Tonemap.                                        \n"
    "    // gData[1].s3 contains lmax2.                     \n"
    "    s0 *= (1.0f + s0 / gData[1].s3)                    \n"
    "           / (1.0f + s0);                              \n"
    "                                                       \n"
    "    gData[gid].s0 = s0;                                \n"
    "}                                                      \n"
    "                                                       \n"
    "__kernel void to_rgb(__global float4 *gPixels,         \n"
    "        __global float4 *unun) {                       \n"
    "    int gid = get_global_id(1) * get_global_size(0)    \n"
    "               + get_global_id(0);                     \n"
    "    float4 result, val;                                \n"
    "    float4 pixel = gPixels[gid];                       \n"
    "                                                       \n"
    "    val.y = pixel.s0;     // Y                         \n"
    "    result.s1 = pixel.s1; // x                         \n"
    "    result.s2 = pixel.s2; // y                         \n"
    "                                                       \n"
    "    if(val.y > 0.0f && result.s1 > 0.0f                \n"
    "           && result.s2 > 0.0f) {                      \n"
    "        val.x = result.s1 * val.y / result.s2;         \n"
    "        val.z = val.x / result.s1 - val.x - val.y;     \n"
    "    }                                                  \n"
    "    else {                                             \n"
    "        val.x = val.z = 0.0f;                          \n"
    "    }                                                  \n"
    "                                                       \n"
    "    // These constants are the conversion coefs.       \n"
    "    pixel = (float4) (0.0f);                           \n"
    "    pixel.s0 += 2.5651f * val.x;                       \n"
    "    pixel.s0 += -1.1665f * val.y;                      \n"
    "    pixel.s0 += -0.3986f * val.z;                      \n"
    "    pixel.s1 += -1.0217f * val.x;                      \n"
    "    pixel.s1 += 1.9777f * val.y;                       \n"
    "    pixel.s1 += 0.0439f * val.z;                       \n"
    "    pixel.s2 += 0.0753f * val.x;                       \n"
    "    pixel.s2 += -0.2543f * val.y;                      \n"
    "    pixel.s2 += 1.1892f * val.z;                       \n"
    "    gPixels[gid] = pixel;                              \n"
    "}                                                      \n"
    "                                                       \n"
    "__kernel void to_bitmap(__global float4 *gIn,          \n"
    "        __global uchar4 *gOut, float toBitmapPower) {  \n"
    "    int gid = get_global_id(1) * get_global_size(0)    \n"
    "               + get_global_id(0);                     \n"
    "    float4 in = gIn[gid];                              \n"
    "    uchar4 out;                                        \n"
    "    in = clamp(in, 0.0f, 1.0f);                        \n"
    "    out.x = (uchar) (255.0f * pow(in.s0, toBitmapPower));\n"
    "    out.y = (uchar) (255.0f * pow(in.s1, toBitmapPower));\n"
    "    out.z = (uchar) (255.0f * pow(in.s2, toBitmapPower));\n"
    "    out.w = 255;                                       \n"
    "    gOut[gid] = out;                                   \n"
    "}                                                      \n";





#endif
